# Vaulton's crypto design

This doc describes how Vaulton derives keys, encrypts data and maps cryptographic material to database fields. It focuses on the client-side “key ladder” and the server-side storage format.

## 1. Goals and assumptions

**Goals:**

- The server should and **will** never see the master password or master key in plaintext form.
- Only opaque ciphertexts, salts, key-wrapping blobs and a user-selected KDF mode are persisted in the database
- A database-only compromise **should not** allow the attacker to decrypt the vault data

**Trade-offs**

- Vaulton is not trying to protect against a fully compromised client due to its zero-knowledge nature (malware, keyloggers, direct access to the client machine)
- Planned local "PIN unlock" is a UX feature that simplifies day-to-day use of the app. While enhancing UX it weakens local security due to PIN being easier to brute-force

## 2. Identity model (high level)

- Each account is identified **only** by an opaque GUID called **AccountId**
- The user is not expected nor asked to enter any usernames or emails in the core design to maintain privacy and protect against cross-site database leaks
- AccountIds are provided by the server by a simple handshake endpoint (`/auth/pre-register`). The client then uses the AccountId to bind and perform locally bound cryptography with AAD.

## 3. Cryptographic primitives and parameters

### 3.1 Client-side primitives

#### **Password KDF mode (Argon2id-backed on the client)**

Vaulton stores a coarse-grained `KdfMode` selector instead of per-user Argon2 parameters. The client still runs Argon2id and maps the mode to a concrete Argon2id profile (currently aligned with libsodium defaults):

- `KdfMode = 1` → Default profile
- `KdfMode = 2` → Strong profile

The per-user salt `S_Pwd` (16 bytes) is stored in the database.

#### **HKDF (HMAC-SHA-256)**

Used to split the password-derived root key into multiple independent keys:

- `K_vrf` (verifier key for auth)
- `K_kek` (key-encryption key for wrapping the Master Key)

HKDF uses fixed, public `info` strings (e.g. `"vaulton/verifier"`, `"vaulton/mk-wrap"`); these do **not** need to be stored per-user.

#### **Master Key (MK) and tag key**

- The Master Key (`MK`) is a randomly generated high-entropy symmetric key (e.g. 256 bits), created on the client during registration.
- `MK` is never sent to the server in plaintext and is **not** used directly for encryption.
- From `MK`, Vaulton derives:
  - `K_enc` for encrypting vault entries with AES-GCM, and
  - `K_tag` for deterministic domain tags.

  `K_enc = HKDF(MK, info = "vaulton/entry-enc")`
  `K_tag = HKDF(MK, info = "vaulton/domain-tag")`

Deriving `K_tag` from `MK` (instead of from the password-derived root key) keeps domain tags independent of password changes: as long as `MK` stays the same, `K_tag` and all existing tags remain valid. A password change only re-wraps `MK` with a new `K_kek` and updates the verifier; it does not require re-tagging all entries.

#### **AES-GCM (AEAD)**

Used on the client to encrypt:

- The randomly generated Master Key (`MK`) under `K_kek` -> `MKWrapPwd`
- (Planned) MK under randomly generated user-held Recovery Key `K_rk` -> `MKWrapRk`
- Each vault entry JSON under `K_enc` -> per-entry { `Nonce`, `CipherText`, `Tag` }

`MKWrapPwd`/`MKWrapRk` are structured values:

- `Nonce` (12 bytes)
- `CipherText` (32 bytes, the wrapped `MK`)
- `Tag` (16 bytes)

Provides confidentiality + integrity,

#### **HMAC-SHA-256 (Domain tags)**

Used with `K_tag` to compute deterministic tags for normalized domains:

`DomainTag = HMAC(K_tag, normalizedDomain)`

Stored server-side to let a planned extension easily fetch entries by domain without decrypting the whole vault.

This intentionally leaks a small amount of information: an attacker (or hosting provider) who can see the database can tell that a given user has, for example, 3 entries with the same `DomainTag`. They still do not learn the actual domain name or any plaintext credentials without the master password (and thus `MK` and `K_tag`), but they can see that those 3 entries belong to the same unknown site.

### 3.2 Server-side primitives

#### **PBKDF2 (HMAC-SHA-256) with pepper**

Used to harden the client-side verifier against database leaks.

Input:

- Raw verifier `Verifier_raw = K_vrf` from the client
- Per-user salt `S_Verifier` (generated by the server during registration and never sent to the client)
- Global secret `Pepper` (kept in configuration, **not** DB)

Output:

- `StoredVerifier = PBKDF2(Verifier_raw || Pepper, S_Verifier, iterations, outputLength)`

Only `StoredVerifier` and `S_Verifier` are stored in the database.

#### **JWT (HS256)**

Used to issue short-lived access tokens after successful login.

- Symmetric signing key stored in configuration.
- Tokens contain `sub = AccountId`, `jti`, `iat`, `exp` (around 20 minutes).

#### **TLS (outside Vaulton scope)**

All communication between client and server is expected to happen over HTTPS.
