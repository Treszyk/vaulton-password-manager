# Vaulton's auth design

This document describes how accounts are created and authenticated in Vaulton. It focuses on the HTTP API, request/response contracts and the session model. Cryptographic details (KDF modes, HKDF, wraps, domain tags, PIN unlock) are described in `crypto.md`.

## 1. Overview

Vaulton uses an anonymous, AccountId-only identity model:

- Every account is identified only by an opaque GUID called **AccountId**.
- There are no usernames or emails in the core design.
- Authentication is based on a **triple verifier system**:
  - `verifier` (Login proof derived from password).
  - `adminVerifier` (Admin proof derived from password).
  - `rkVerifier` (Recovery proof derived from a random Recovery Key).
- After successful login the server issues:
  - a short-lived **JWT access token** (returned in the JSON response), and
  - a long-lived **refresh token** stored as an HttpOnly cookie (`Vaulton.Refresh`) or returned in JSON for extension compatibility.

Registration is split into a **pre-register handshake** to obtain a fresh `AccountId`, followed by a **register** call where the client uploads its cryptographic material (verifiers, salts, MK wraps, KDF mode).

The auth layer proves knowledge of the password/recovery-key and establishes a session. Vault decryption and local UX (including Passcode unlock) happen entirely on the client.

In the current prototype all accounts use **`CryptoSchemaVer = 1`**. No branching based on this value is implemented yet; it is reserved for future cryptographic migrations.

## 2. Identity and account lifecycle

### 2.1 Identity model

- Vaulton uses an AccountId-only identity model (as described above).
- The server allocates new opaque GUIDs called **AccountId** and guarantees they are unique.
- On the web client, the frontend stores the AccountId locally (for example in IndexedDB) so the user does not have to type or paste it on every visit.

### 2.2 Account creation (high level)

1. The client calls `POST /auth/pre-register` to obtain a fresh `AccountId`.
2. The client derives all cryptographic material locally from:
   - The master password.
   - Per-user salt `S_Pwd` (16 bytes).
   - Randomly generated Master Key (`MK`) and Recovery Key (`RK`).
3. The client calls `POST /auth/register` with:
   - `AccountId`.
   - `verifier`, `adminVerifier`, and `rkVerifier` (raw proofs).
   - `S_Pwd` (The master KDF salt, generated by the client).
   - `KdfMode` selector.
   - `MkWrapPwd` and `MkWrapRk`.
   - `CryptoSchemaVer`.
4. The server receives the proofs and generates its own **verifier salts**:
   - `S_Verifier` (for `verifier`)
   - `S_AdminVerifier` (for `adminVerifier`)
   - `S_Rk` (for `rkVerifier`)
5. The server hashes the client's proofs with these salts using PBKDF2 (and a server-side pepper) and stores the final **stored verifiers**. It never sees the password or the master key in plaintext.

![Registration Flow](/docs/diagrams/registration-flow.jpeg)

### 2.3 Login (high level)

1. The client calls `POST /auth/pre-login` with the `AccountId` to fetch the per-user `S_Pwd` and `KdfMode`.
2. The user provides their master password. The client recomputes the `verifier` using Argon2id + HKDF.
3. The client calls `POST /auth/login` with `{ AccountId, Verifier }`.
4. On success the server:
   - Issues a short-lived JWT access token.
   - Sets a refresh token cookie (`Vaulton.Refresh`) or returns it in JSON.
   - Returns both `MKWrapPwd` and `MKWrapRk` so the client can immediately begin decryption.
5. The client uses the access token to call protected endpoints. The refresh token is used to obtain new access tokens.

![Login Flow](/docs/diagrams/login-flow.jpeg)

### 2.4 Session vs vault unlock (conceptual)

Vaulton distinguishes between:

- **Being logged in**: there is a valid refresh token and access token; the server knows which AccountId the client is acting as.
- **Vault being unlocked**: the client has a usable Master Key (`MK`) in memory and can decrypt and encrypt entries.

Closing the tab or reloading the page clears JavaScript memory (`MK` is gone), but the refresh token cookie may still be valid. On next load the frontend:

- Uses `POST /auth/refresh` to re-establish an access token (logged-in state), and
- Asks the user for the master password (or their local passcode) to recover MK and unlock the vault.

## 3. Endpoints

### 3.1 POST /auth/pre-login

**Purpose**  
Fetches the user's password salt and KDF configuration before they compute the verifier. To prevent account enumeration, the server returns deterministic "fake" data for unknown `AccountId`s.

**Request (JSON)**

    {
      "AccountId": "4e3d1c7d-9f9e-4a31-b720-9f6a2a6e3f5a"
    }

**Response (200 OK)**

    {
      "S_Pwd": "base64(16 bytes)",
      "KdfMode": 1,
      "CryptoSchemaVer": 1
    }

### 3.2 POST /auth/pre-register

**Purpose**  
Allocate a new, unused `AccountId` for a future account. This call does not create a user record yet.

**Request**

- Method: POST
- Path: `/auth/pre-register`
- Body: empty JSON object `{}` or no body.

**Response (200 OK)**

    {
      "AccountId": "4e3d1c7d-9f9e-4a31-b720-9f6a2a6e3f5a"
    }

Notes:

- The server generates a GUID and ensures it is not already used as a `User.Id`.
- The client persists this AccountId locally (e.g. IndexedDB) and uses it in the subsequent `/auth/register` call.
- If the client never calls `/auth/register`, this AccountId simply remains unused.

### 3.3 POST /auth/register

**Purpose**  
Create a new user account, storing only verifier hashes, salts, wraps and the KDF mode selector.

The client must have already:

- Derived `verifier`, `adminVerifier`, and `rkVerifier`.
- Generated a random Master Key (`MK`) and Recovery Key (`RK`).
- Derived `kekKey` and computed `MkWrapPwd`.
- Derived `rkKek` and computed `MkWrapRk`.
- Selected a `KdfMode` (currently `1 = Default`, `2 = Strong`).

**Request (JSON)**

    {
      "AccountId": "4e3d1c7d-9f9e-4a31-b720-9f6a2a6e3f5a",
      "Verifier": "base64(32 bytes)",
      "AdminVerifier": "base64(32 bytes)",
      "RkVerifier": "base64(32 bytes)",
      "S_Pwd": "base64(16 bytes)",
      "KdfMode": 1,
      "MkWrapPwd": {
        "Nonce": "base64(12 bytes)",
        "CipherText": "base64(32 bytes)",
        "Tag": "base64(16 bytes)"
      },
      "MkWrapRk": {
        "Nonce": "base64(12 bytes)",
        "CipherText": "base64(32 bytes)",
        "Tag": "base64(16 bytes)"
      },
      "CryptoSchemaVer": 1
    }

**Response (201 Created)**

    {
      "AccountId": "4e3d1c7d-9f9e-4a31-b720-9f6a2a6e3f5a"
    }

**Server behaviour (conceptual)**

1. Validate the request (required fields present, base64 decodes, etc.).
2. Ensure `AccountId` is not already in use.
3. Generate three random per-user PBKDF2 salts: `S_Verifier`, `S_AdminVerifier`, and `S_Rk`.
4. Compute the stored verifiers using PBKDF2+pepper:

   storedVerifier = PBKDF2(verifier || Pepper, S_Verifier, iterations, 32)
   storedAdminVerifier = PBKDF2(adminVerifier || Pepper, S_AdminVerifier, iterations, 32)
   storedRkVerifier = PBKDF2(rkVerifier || Pepper, S_Rk, iterations, 32)

5. Create a new `User` row with:
   - `Id = AccountId`
   - `Verifier`, `AdminVerifier`, `RkVerifier` (the stored hashes)
   - `S_Verifier`, `S_AdminVerifier`, `S_Rk`
   - `S_Pwd` (from client)
   - `MkWrapPwd`, `MkWrapRk`
   - `KdfMode`, `CryptoSchemaVer`
   - Timestamps (`CreatedAt`, `UpdatedAt`)
6. Save to the database and return `201 Created`.

**Error cases**

- AccountId already used → `400 Bad Request`, generic message:

      {
        "message": "Account cannot be created."
      }

- Invalid crypto blob sizes → `400 Bad Request`:

      {
        "message": "Invalid crypto blob sizes."
      }

- Unsupported KDF mode → `400 Bad Request`:

      {
        "message": "Invalid KDF mode."
      }

- Unsupported crypto schema version → `400 Bad Request`:

      {
        "message": "Unsupported crypto schema version."
      }

### 3.4 POST /auth/login

**Purpose**  
Authenticate an existing account by verifying the password-derived verifier and return an access token plus a refresh cookie.

The client must:

- Know the `AccountId` (from local storage or manual entry).
- Re-derive `Verifier = K_vrf` from the password using `S_Pwd` and the `KdfMode` from the `User` record.

**Request (JSON)**

    {
      "AccountId": "4e3d1c7d-9f9e-4a31-b720-9f6a2a6e3f5a",
      "Verifier": "base64(K_vrf)"
    }

**Response (200 OK)**

    {
      "Token": "jwt-access-token-here",
      "MkWrapPwd": { "Nonce": "...", "CipherText": "...", "Tag": "..." },
      "MkWrapRk": { "Nonce": "...", "CipherText": "...", "Tag": "..." }
    }

In addition to the JSON body, the server also sets a refresh token cookie, for example:

- Name: `Vaulton.Refresh`
- Flags: `HttpOnly`, `SameSite=Strict`, `Secure` unless running in development
- Path: `/auth`
- Expires: several days in the future

The refresh token value itself is a random opaque string (not a JWT). Only a hash of this value is stored in the database.

**Server behaviour (conceptual)**

1.  Look up the `User` row by `AccountId`.
2.  If no user is found:
    - Perform a dummy PBKDF2 step to avoid timing-based user enumeration.
    - Return `401 Unauthorized` with a generic error.
3.  If user exists:
    - Read `S_Verifier` and stored verifier hash (`StoredVerifier`).
    - Compute:

          computed = PBKDF2(verifier || Pepper, sVerifier, iterations, 32)

    - Compare `Computed` to `StoredVerifier` using constant-time equality.

4.  On success:
    - Clear any login lockout counters and update `LastLoginAt`.
    - Issue a short-lived JWT access token via `ITokenIssuer`.
    - Generate a new refresh token value, store its hash in the database and set the `Vaulton.Refresh` cookie.
    - Return `200 OK` with `{ "Token": "<jwt>" }`.

**Error cases**

- Wrong password / wrong verifier / unknown AccountId / locked-out account -> always:

      HTTP/1.1 401 Unauthorized
      {
        "message": "Invalid credentials."
      }

  (No difference in message between “account not found” and “bad password”.)

- Invalid body (missing fields, invalid base64, etc.) → for example:

      HTTP/1.1 400 Bad Request
      {
        "message": "Invalid request."
      }

### 3.5 POST /auth/refresh

**Purpose**  
Rotate the refresh token and issue a new access token without requiring the password again.

**Request**

- Method: POST
- Path: `/auth/refresh`
- Body: empty JSON object `{}` or no body.
- The refresh token is sent automatically by the browser as an HttpOnly cookie (`Vaulton.Refresh`).

**Response (200 OK)**

    {
      "Token": "new-jwt-access-token-here"
    }

**Server behaviour (conceptual)**

1. Read the refresh token value from the cookie.
2. Look up the corresponding refresh token record in the database by a SHA-256 hash of this value.
3. Validate:
   - Token exists and is not revoked.
   - Token belongs to an existing `AccountId`.
   - Token is not expired.
4. If validation fails → return:

   HTTP/1.1 401 Unauthorized
   {
   "message": "Invalid refresh token."
   }
   - If the token is found but already revoked, the server also revokes all other active refresh tokens for that account.

**Error cases**

- Missing refresh cookie → `401 Unauthorized`:

      {
        "message": "Missing refresh token."
      }

- Invalid/expired/revoked refresh token → `401 Unauthorized`:

      {
        "message": "Invalid refresh token."
      }

5. If validation succeeds:
   - Create a new JWT access token for the associated `AccountId`.
   - Generate a new refresh token value.
   - Store the new refresh token hash in the database and mark the old one as revoked (rotation).
   - Set a new `Vaulton.Refresh` cookie with the new value (HttpOnly, `SameSite=Strict`, `Path=/auth`, `Secure` unless running in development).
   - Return `200 OK` with `{ "Token": "<new-jwt>" }`.

### 3.6 POST /auth/logout

**Purpose**  
Invalidate the current refresh token and remove its cookie.

**Request**

- Method: POST
- Path: `/auth/logout`
- Body: empty JSON object `{}` or no body.
- Uses the refresh token cookie (if present) to identify which session to revoke.

**Server behaviour (conceptual)**

1. Read the refresh token value from the cookie, if present.
2. Revoke or delete the corresponding refresh token record in the database.
3. Set the `Vaulton.Refresh` cookie with an immediate expiry (clearing it in the browser).
4. Return `204 No Content`.

If no valid refresh token is present, the endpoint still returns success; logout is idempotent.

### 3.7 POST /auth/logout-all

**Purpose**
Invalidate all active refresh tokens for the authenticated account and remove the cookie.

**Request**

- Method: POST
- Path: `/auth/logout-all`
- Requires a valid access token (`Authorization: Bearer <token>`).

**Server behaviour (conceptual)**

1. Read `sub` from the JWT and parse it as `AccountId`.
2. Revoke all non-revoked refresh tokens for that account.
3. Delete the refresh cookie (`Vaulton.Refresh`).
4. Return `204 No Content`.

### 3.8 GET /auth/me

**Purpose**
Return the `AccountId` for the current access token.

**Request**

- Method: GET
- Path: `/auth/me`
- Requires a valid access token (`Authorization: Bearer <token>`).

**Response (200 OK)**

    {
      "AccountId": "4e3d1c7d-9f9e-4a31-b720-9f6a2a6e3f5a"
    }

### 3.8 POST /auth/recovery-wraps

**Purpose**  
Fetches the `MkWrapPwd` and `MkWrapRk` blobs for an account. Requires the `RkVerifier` (recovery proof) to authorize the release of these encrypted Master Key wraps. This prevents unauthorized access to encrypted blobs and provides protection against account enumeration.

**Request (JSON)**

    {
      "AccountId": "4e3d1c7d-9f9e-4a31-b720-9f6a2a6e3f5a",
      "RkVerifier": "base64(32 bytes)"
    }

**Response (200 OK)**

    {
      "MkWrapPwd": { "Nonce": "...", "CipherText": "...", "Tag": "..." },
      "MkWrapRk": { "Nonce": "...", "CipherText": "...", "Tag": "..." },
      "KdfMode": 1,
      "CryptoSchemaVer": 1
    }

### 3.9 POST /auth/recover

**Purpose**  
Resets account credentials (verifier, salt, wraps) using the Recovery Key proof (`RkVerifier`).

**Request (JSON)**

    {
      "AccountId": "4e3d1c7d-9f9e-4a31-b720-9f6a2a6e3f5a",
      "RkVerifier": "base64(32 bytes)",
      "NewVerifier": "base64(32 bytes)",
      "NewAdminVerifier": "base64(32 bytes)",
      "NewRkVerifier": "base64(32 bytes)",
      "NewS_Pwd": "base64(16 bytes)",
      "NewKdfMode": 1,
      "NewMkWrapPwd": { ... },
      "NewMkWrapRk": { ... },
      "CryptoSchemaVer": 1
    }

**Response (200 OK or 204 No Content)**

### 3.10 POST /auth/wraps (Admin)

**Purpose**  
Fetches the current Master Key wraps. Requires the `AdminVerifier`. This is used during the "Password Change" (Rekey) flow to ensure the user still has administrative rights before they can rotate keys.

**Request (JSON)**

    {
      "AccountId": "4e3d1c7d-9f9e-4a31-b720-9f6a2a6e3f5a",
      "AdminVerifier": "base64(32 bytes)"
    }

**Response (200 OK)**

    {
      "MkWrapPwd": { ... },
      "MkWrapRk": { ... },
      "KdfMode": 1,
      "CryptoSchemaVer": 1
    }

### 3.11 POST /auth/change-password (Admin)

**Purpose**  
Updates all account credentials and wraps. Requires the `AdminVerifier`.

**Request (JSON)**  
(Similar to `/auth/recover` but uses `AdminVerifier` instead of `RkVerifier`).

### 3.12 Extension-Specific API (`/auth/ext/*`)

Browser extensions often operate in environments where cookie-based authentication is restricted or less reliable. Vaulton provides a parallel set of stateless endpoints that return tokens in the JSON response body.

- **`POST /auth/ext/login`**: Authenticates and returns `{ Token, RefreshToken, RefreshExpiresAt, MkWrapPwd, MkWrapRk }`.
- **`POST /auth/ext/refresh`**: Takes a `RefreshToken` in the body and returns a new `{ Token, RefreshToken, RefreshExpiresAt }`.
- **`POST /auth/ext/logout`**: Revokes the provided `RefreshToken`.
- **`POST /auth/ext/logout-all`**: Revokes all refresh tokens for the account.

## 4. Session model

Vaulton supports two session models:

1.  **Web (Cookie-based)**:
    - `access_token` in JSON body.
    - `refresh_token` in `HttpOnly` cookie.
    - Best for standard web applications to prevent token theft via XSS.
2.  **Extension (Token-based)**:
    - Both tokens returned in JSON.
    - `refresh_token` stored manually by the extension in `chrome.storage.local`.
    - Allows stateless operations across different browser contexts.

## 5. Security considerations

- **Triple Verifier**: Separation of concerns between login, sensitive admin actions, and recovery.
- **Constant-Time Comparison**: Server-side verifier checks are protected against timing attacks.
- **Deterministic Fake Data**: `/auth/pre-login` and `/auth/recovery-wraps` return consistent data for non-existent accounts to prevent enumeration.
- **Lockout Policy**: Aggressive 5-fail lockout for all verifier-based endpoints.
- **Token Rotation**: Refresh tokens are one-time use; reuse of an old token triggers a global session revocation for that user.
